kahua.test.xml

[module] kahua.test.xml

このモジュールは HTML を生成するコード、たとえば、CGIプログラムの結果
をテストする手段を提供するものです。こうしたコードの出力は、テストを
書いたときには、分らない情報が含まれることがあります。このような情報
の例としては、タイムスタンプやセッションＩＤがあります。

test-xml-match? 手続きはテストされるコードの出力にマッチするパターン
を使います。このパターンには、「don't care」節を含めることができま
す。また、いくつかの制約をチェックするのに使えるパターン変数も含めら
れます。

[procedure] test-sxml-match? pattern input [extra-check]

inputはSXML。patternは、照合すべきパターンを表現するS式。

パターンはSXMLに類似したS式ですが、パターン変数を含めることが出来ま
す。形式的仕様は以下のようになっています。

    <pattern> : <node>
    <node>    : <string> | <pattern-variable>
              | (<key> <attr-node>? <content> ...)
    <key>     : <literal-symbol>

    <attr-node> : (@ <content> ...)
                | ?@

    <content> : <node>
              | (!seq     <pattern> ...)
              | (!permute <pattern> ...)
              | (!or      <pattern> ...)
              | (!repeat  <pattern> ...)

    <literal-symbol> : 先頭が'?'あるいは'!'ではないすべてのシンボル

    <pattern-variable> : 先頭が'?'であるシンボル

<string> と <literal-symbol> はそのまま入力と照合されます。

<pattern-variable> は入力中のすべてのオブジェクトとマッチします。照合
器はパターン変数とマッチしたオブジェクトとを記録します。これらは、後
述の追加チェック手続きによる追加チェックで使われます。

(現バージョンでは、パターン変数名については、何を使ってもかまいません
しかし、将来、同じ変数名なら同型の構造を参照するという制約を加える可
能性があります。「don't care」部分を表現するのに、パターン変数 ?_ を
使います。これは、その用途のために予約します。)

パターン変数?@は、attr-nodeがもしあればそれにマッチします。アトリビュ
ートを無視したい場合に便利です。

<attr-node>内の<content>は対応する入力のアトリビュートノードの内容
に、順不動でマッチします。

パターン変数?*は、(!repeat ?_)と同じです。

(!seq <pattern> ...)

    <pattern> ... の並びにマッチします。<content> の外観であれば
    <pattern> ... は繋ぎあわされて <content> の並びとなります。すなわ
    ち、以下のパターン

    (ul (li "foo") (!seq (li "bar") (li "baz")) (li "oof"))

    は、以下の入力とマッチします。

    (ul (li "foo") (li "bar") (li "baz") (li "oof"))

(!permute <pattern> ...)

    <pattern> ... のすべての順列のどれかの並びにマッチします。並び
    は、繋ぎあわされ <content> の並びを含むものになります。すなわち、
    以下のパターン

    (ul (li "foo") (!permute (li "bar") (li "baz")) (li "oof"))

    は以下の入力にマッチします。

    (ul (li "foo") (li "baz") (li "bar") (li "oof"))

(!or <pattern> ...)

    <pattern> ... のいずれかにマッチします。繋ぎあわせのルールは再帰
    的に適用されます。以下のパターン

    (ul (li "foo") (!or (!seq (li "bar") (li "baz")) (li "ZZ")))

    は、以下の入力の両方にマッチします。

    (ul (li "foo") (li "bar") (li "baz"))
    (ul (li "foo") (li "ZZ"))

(!repeat <pattern> ...)

    入力のなかの <pattern> ... にマッチするもののゼロ個以上の出現にマ
    ッチします。各反復中で、マッチしたパターン変数は最後をのぞき保存
    されません。パターン

    (dl (!repeat (dt ?_) (dd ?_)))

    は以下の入力にマッチします。

    (dl (dt "foo") (dd "bar") (dt "foo2") (dd "bar2"))

オプション引数 extra-check を与えると、これは、パターン変数とマッチし
た値との連想リストを引数として呼び出されます。extra-checkは追加のチェ
ックを行い、失敗したら #f を、成功したら真の値を返さねばなりません。

test-sxml-match? は照合が成功した場合には#fを、照合が成功し、かつ
extra-checkが与えられていない場合は#tを、照合が成功し、 extra-checkが
与えられている場合はextra-checkの返り値を返します。

パターンのバックトラックにより、extra-checkは単一のテストで複数回呼ば
れ得ることに注意して下さい。

extra-checkがない場合、test-sxml-match? は gauche.test モジュールの
test手続きやtest*マクロに、比較手続きとして直接渡すことができます。

(test* "test sxml output" '(ul (!repeat (li ?_)))
       (sxml-generating-procedure)
       test-sxml-match?)

このような使用法を想定しているため、input に*test-error*が渡された場
合 (sxml-generating-procedure 実行中にエラーが発生すると、 test*がそ
れを補足して *test-error* オブジェクトへとラップします)、
test-sxml-match? はマッチを一切行わず、直ちに#fを返します。

[procedure] test-xml-match? pattern input [extra-check]

inputは文字列もしくはリストです。リストの場合、それはまずtext.treeモ
ジュールのtree->string手続きに渡されて、文字列を生成します。

次にその文字列がssax:xml->sxmlに渡され、XMLとしてパーズされます。

結果のSXMLが、test-sxml-match? に渡されます。

test-sxml-match? と同様、inputに*test-error*が渡された場合はマッチを
一切行わず、直ちに#fを返します。

[procedure] test-sxml-select-matcher sxpath-expr [extra-check]

[procedure] test-xml-select-matcher sxpath-expr [extra-check]

これらの手続きは、与えられたSXPath選択ルールを入力に最初に適用してか
らそれぞれtest-sxml-match?, test-xml-match? を適用するような手続きを
返します。大きなXML出力のうち特定のノードのみをテストしたいような場合
に便利です。

例えば、次の例は、テスト結果の戻り値のSXML式から、body要素内の p要素
列を選択したものに対して、与えられたパターンとの照合を行います。

(test* "test sxml output" '(!seq (p ?_) (p ?_))
       '(html (head (title "TEST"))
              (body (h1 "Test page") (p "a") (p "b")))
       (test-sxml-select-matcher '(html body p)))

返された手続きは、その第二引数に*test-error*が渡された場合はマッチを
行わず、ただちに#fを返します。
