;; This document is obsoleted.
;; We should rewrite this until release of 1.0.
;;
;; $Id: hello-kahua.ja,v 1.2 2006/12/13 08:45:39 bizenn Exp $
;;
hello-kahua

はじめての Kahua

以下は現状の Kahua の利用方法、Kahuaアプリケーションの作成方法の解説ですので変
更する可能性があります。

本資料を読むときに必要なのは次のとおりです。

 ・ scheme のちょっとした知識（lambda とは、define とは何か、とか）
 ・ Guache を動かすことのできる環境（Cygwin上では Kahua は動作しません）

 ・ はじめての Kahua
     □ インストール
         ☆ Kahua をインストールしよう
         ☆ サンプルプログラムをインストールしよう
     □ 動かしてみよう
         ☆ アクセスしてみる
         ☆ サンプルで遊んでみる
         ☆ kahua-web で遊んでみる
     □ はじめての Kahua プログラム
         ☆ Kahua の基本
         ☆ ファイル・ディレクトリ構成
             ○ app-servers
             ○ checkout ディレクトリ
         ☆ hello Kahua!
         ☆ hello を動かそう
         ☆ hello の解説
         ☆ もっと hello - エントリを追加しよう
         ☆ もっともっと hello - 継続を使ってみよう
         ☆ もっともっともっと hello - オブジェクトデータベースを使ってみよう
             ○ オブジェクトデータベース補足
         ☆ hello 全部
     □ Kahua プログラミング環境
         ☆ kahua-admin の利用
         ☆ kahua-shell の利用
         ☆ Emacs との連携
         ☆ ユーザ別 Kahua 環境の利用
         ☆ テストの作成
     □ 終わりに

インストール

詳細は Kahua パッケージに含まれている INSTALL ファイルを参照してください。もし
くは Setup をご覧下さい。

また、Kahua を利用するためには Gauche 0.7.4.2 が必要です。適宜、インストールし
てください。

Kahua をインストールしよう

最新版は CVS版になります。CVS から取ってきた場合、次にようにしてください。

$ ./DIST gen # CVS版のみ取ってきたときだけ
$ ./configure --with-cgidir=[どっか]

この cgidir は、apache などで実行する CGI を配置できるディレクトリを指定してく
ださい。そこに後述する kahua.cgi を置くことになります。

$ make
$ su              # root になって
$ make install
$ exit            # root じゃなくなって

ここで、kahua.conf を作ります。現状では /usr/local/etc/kahua/kahua.conf がデフ
ォルト位置です。このファイルに次のように書いてください。

(make <kahua-config>
  :sockbase             "unix:/usr/local/tmp/kahua"
  :working-directory    "/usr/local/var/kahua"
  :static-document-path "/var/www/html/kahua"
  :static-document-url  "/kahua"

  :auto-restart         #t
  )

この設定では、

 ・ /usr/local/var/kahua に作業用ディレクトリができます。
 ・ 動的に生成されない静的なファイル、たとえばイメージなどは
    /var/www/html/kahua 以下に置くようになります。
 ・ その静的なページへは、apache 経由でアクセスするときは /kahua/... になりま
    す。

ご自分の環境にあわせた設定を行ってください。

ちなみに私は自分のホームディレクトリ以下に作っております。この場合、パーミッシ
ョンにおいて楽をすることができます。つまり、後述する設定を省くことができます。
試験用にはいいんじゃないでしょうか。

;; /home/ko1 がホームディレクトリだった場合、
(make <kahua-config>
  :sockbase             "unix:/home/ko1/tmp/kahua"
  :working-directory    "/home/ko1/kahua"
  :static-document-path "/home/ko1/kahua/static"
  :static-document-url  "/static"
  )

詳細： kahua.config

その後、kahua.conf で設定した内容に従って、必要ならグループおよび権限の設定を
してください。

$ chgrp -R [kahua] [KAHUA_WORKDIR] [KAHUA_SOCKBASE] [KAHUA_DOCDIR]
$ chmod -R g+ws [KAHUA_WORKDIR] [KAHUA_SOCKBASE] [KAHUA_DOCDIR]

KAHUA_SOCKBASE: ソケットを作成するディレクトリ。デフォルトは
/usr/local/tmp/kahua。 :sockbase で設定したディレクトリ。

KAHUA_WORKDIR: 作業ファイルディレクトリ。デフォルトは/usr/local/var/kahua。
:working-directory で設定したディレクトリ。

$KAHUA_DOCDIR 静的ドキュメントディレクトリ。デフォルトは/var/www/kahua。
:static-document-path で設定したディレクトリ。

サンプルプログラムをインストールしよう

で、例をインストールします。

$ su [kahua の実行するためのユーザ]
$ make install-examples [KAHUACONFIG="-c [kahua.conf の場所]"]

KAHUACONFIG="-c [kahua.conf の場所]" は、kahua.conf を
/usr/local/etc/kahua/kahua.conf 以外に設定した場合に指定してください。

以下、kahua-* プログラムではこのオプションが必要になりますが、オプション "-c
..." の意味はこれと同じです。

動かしてみよう

$ kahua-spvr -i [KAHUACONFIG="-c [kahua.conf の場所]"]

を実行してみましょう。

"kahua> " というプロンプトが表示されましたね。

おめでとうございます！成功です！

-i を忘れると何も言ってくれませんので注意が必要です。デーモンとして動作させる
ような、本番運用では -i オプションは必要なくなると思います。

アクセスしてみる

ウェブブラウザで kahua.cgi にアクセスしてみてください。

kahua.cgi を置いたところ（デフォルトでは /usr/lib/cgi-bin/ に置かれます）に、
ウェブサーバへアクセスします。デフォルトで http ://localhost/cgi-bin/kahua.cgi
になる気がします。ウェブサーバの設定に依存します。ご注意ください。

サンプルで遊んでみる

現在、 make install-examples を実行すると、次のようなサンプルアプリケーション
がインストールされます。もちろん、すべて Kahua を用いて記述してあります。

 ・ lambdabooks : オンライン本屋風サンプルアプリケーション
 ・ wiki-iki : Kahua による Wiki の実装
 ・ login : ユーザ管理用アプリケーション
 ・ nqueen : Kahua の継続を利用して複雑な計算をインタラクションをとりながら進
    めていくアプリケーションをこれだけ短くかけました、というサンプル
 ・ lazy-nqueen : nqueen を遅延評価を利用して実装したサンプル
 ・ foldlist : ツリーを開いたり閉じたりする単純なサンプル

これらは、http ://.../kahua.cgi/lambdabooks などと kahua.cgi 以降にアプリケー
ション名を追加してアクセスすることができます。

lambdabooks や wiki-iki は Kahua でこういうアプリケーションが作れるんだ、とい
うことを知ってもらうためのサンプルです。ですが、その分ちょっと大きいです。

foldlist などは、規模が非常に小さく、どうやって書くのかな、というのをちょっと
ソースを見てみるか、というむきにはいいと思います。ソースは設定した
[working-directory]以下の [working-directory]/checkout/foldlist/foldlist.kahua
にあります。

kahua-web で遊んでみる

Kahua プロジェクトが送るキラーアプリケーション第一弾（多分）である kahua-web
も、もちろんご利用いただけます。

インストールや使い方などの詳細はkahua-web をごらんください。

はじめての Kahua プログラム

サンプルを実行されましたでしょうか。あのようなウェブアプリケーションが Scheme
で簡単に実現できるのが Kahua のすごいところです。

本項では、この Kahua プログラムを書くための基礎の基礎をご説明いたします。

Kahua の基本

Kahua アプリケーションの記述方法を説明する前に、まず Kahua の基本的なコンセプ
トを並べておきます。

Kahua はアプリケーションサーバを作るためのインフラストラクチャです。次のような
特徴があります。

 ・ だいたい Scheme でかかれています。
 ・ いくつかのアプリケーションサーバをいっぺんに起動したりします。
 ・ アプリケーションサーバは *.kahua というファイルで記述します。
 ・ *.kahua の実行はサンドボックス上で実行され、危ないことは出来ません。
 ・ *.kahua の機能を拡張するため、プラグインを提供することができます。
 ・ 継続ベースのウェブアプリケーションサーバが簡単に作れます。
 ・ 標準で永続化データベースが簡単に使えます。
 ・ クラスの再定義機構が利用できます。
 ・ Emacs との連携で簡単に開発ができます。
 ・ ほかにもいろんな機能があります。

ウェブサーバアプリケーション作成について言えば、次のような利点があります。

 ・ 複数のインタラクションが必要なウェブページを一つの手続きで作成できます。
 ・ CGI インターフェースによって面倒なことは一切必要ありません。

詳細： About Kahua Servers

ずらずらと並べましたが、全部ここで理解しないと進めない、というものではありませ
んので「こんなもんか」と思ってもらえれば結構です。これらの特徴についてはおいお
いご説明していきます。

ファイル・ディレクトリ構成

Kahua の利用するディレクトリ、およびファイルの構成をまずはおさえておきましょ
う。

kahua.conf で :working-directory というのを設定しましたが、これがKahua システ
ムにおいて非常に重要なディレクトリになります。以下、ここで設定したディレクトリ
を work-dir と呼びます。

work-dir 以下のファイル・ディレクトリ構成は次のようになっています。

$(working-directory)/app-servers  ;; 重要
                     checkout/    ;; 重要
                     [その他]/    ;; 知らなくてもいいです。というか、私もよく知りません。

app-servers

詳細： kahua-spvr

このファイルにはどんなアプリケーションサーバを起動するかを書いておきます。たと
えば次のように記述します。

;;; app-servers の例
(
;; (<type> :arguments (<arg> ...) :run-by-default <num>)
;; See http://www.kahua.org/cgi-bin/index.cgi/kahua-spvr
 (lambdabooks   :arguments () :run-by-default 1)
 (wiki-iki      :arguments () :run-by-default 1)
 (login         :arguments () :run-by-default 1)
)

この場合、lambdabooks、wiki-iki、login というアプリケーションサーバが利用でき
るようになっています。

:run-by-default を 0 以外の数字に変更した場合、その数字だけそのアプリケーショ
ンサーバプロセスを起動します。ここは何も気にしないで 1 にしておいてください。

checkout ディレクトリ

checkout ディレクトリ以下にはアプリケーションサーバごとに *.kahua を配置しま
す。

たとえば、アプリケーションサーバ hello を置くときには、
$(working-directory)/checkout/hello/hello.kahua が絶対に必要になります。アプリ
ケーションサーバを起動するとき、これを起動します。

hello Kahua!

では、最初の Kahua プログラム、hello.kahua を作ってみましょう。

まず、設計しましょう。

アクセスされたら簡単のために次のような html が返るようにしましょうか。

<html>
  <head>
    <title> hello kahua! </title>
  </head>
  <body>
    <h1> Hello Kahua! </h1>
  </body>
</html>

とても簡単なサンプルであくびが出そうですが、こちらも考えるのが面倒なのでこうい
うのでお茶を濁すことにします。

では、$(working-directory)/checkout/hello/hello.kahua の作成を開始しましょう。

(define (hello-kahua)
  (html/ (head/ (title/ "hello kahua!"))
         (body/ (h1/ "Hello Kahua!"))))

(initialize-main-proc hello-kahua)

こんな感じでしょうか。ここでは細かいことは気にしないでおいてください。

hello を動かそう

まず、app-servers に hello アプリケーションを追加します。

;;; app-servers の例
(
;; (<type> :arguments (<arg> ...) :run-by-default <num>)
;; See http://www.kahua.org/cgi-bin/index.cgi/kahua-spvr
 (lambdabooks   :arguments () :run-by-default 1)
 (wiki-iki      :arguments () :run-by-default 1)
 (login         :arguments () :run-by-default 1)
 (hello         :arguments () :run-by-default 1) ;; <<- 追加
)

そして、kahua-spvr を（もしまだ動いていれば）再起動してください。 kahua-spvr
の終了は Control-C です。

では、ブラウザで http : //.../kahua.cgi/hello へアクセスしてみましょう。

<html><head><title>hello kahua!</title
></head
><body><h1>Hello Kahua!</h1
></body
></html
>

のような html が返ってくると思います。というか、今やったら返ってきました。予想
していたのとはインデントが違うような気がしますが、意味的には同じですね。よかっ
た、成功です。

おめでとうございます。あなたも立派な Kahua デベロッパーです。

hello の解説

hello.kahua に書いたものの意味がわからなくて気が狂いそうなあなたのために、少し
解説します。

initialize-main-proc は、このアプリケーションサーバに接続されたときに起動する
scheme の手続きです。ここで指定する手続きは HTML要素を返す手続きを返さないとい
けません。（本当は、html要素をあらわすシンボルの tree でもいいんですが）

って書いてもよくわかりませんね。私もわかりません。具体的には hello-kahua 手続
きを見てみましょう。

再掲：
(define (hello-kahua)
  (html/ (head/ (title/ "hello kahua!"))
         (body/ (h1/ "Hello Kahua!"))))

html/ とか、見覚えがありますねぇ。多分、これが <html> </html>要素になりそうで
す。他にも、(h1/ "Hello Kahua!") っていうのが <h1> Hello! Kahua! </H1>になりそ
うです。

これらの手続きは、html要素を返す手続きを生成して（本当はもう少し複雑）くれるそ
うです。簡単ですね。

これらを利用して HTML のページが記述できます。

もっと hello - エントリを追加しよう

さすがにこれだけだと石を投げられそうなので、もう少しリッチなアプリケーションを
考えてみましょう。

kahua.cgi/hello/world

とアクセスされたとき、別のアクションをするようにしてみましょう。

このような用途のためには、 define-entry を使います。

(define-entry (world)
  (html/ (head/ (title/ "hello kahua! - world"))
         (body/ (h1/ "Hello Kahua!")
                (h2/ "Hello World!"))))

上記のスクリプトを、さっきの hello.kahua に追加してください。

これで、kahua.cgi/hello/world とアクセスすると、

<html><head><title>hello kahua! - world</title
></head
><body><h1>Hello Kahua!</h1
><h2>Hello World!</h2
></body
></html
>

が返ってきます。

さて、html とか body とか、同じような要素があるから、ちょっとリファクタリング
しましょう。

;; -*-scheme-*-
;; hello.kahua

(define (page ttl . elems)
  (html/ (head/ (title/ ttl))
         (body/ (node-set elems))))


(define (hello-kahua)
  (page "hello kahua!" ;; title
        (h1/ "Hello Kahua!")))

(define-entry (world)
  (page "hello kahua! - world"
        (h1/ "Hello Kahua!")
        (h2/ "Hello World!")))

(initialize-main-proc hello-kahua)

こんな感じですかね。page という手続きで全体のページデザインをまとめてみまし
た。簡単な Scheme プログラムですね。

node-set という関数が出てきましたが、(list (xxx/ ...) (yyy/ ...) ...) をまとめ
て一つの関数にするものです。リストが出てきたら使いましょう。

もっともっと hello - 継続を使ってみよう

継続ベースとか言ってるのに継続が出てこないじゃないか！　と思った人のために、そ
ろそろ継続を使ったサンプルを書いてみましょう。

さて、kahua の継続は、「Scheme つったら call/cc だろう！」と思ってしまう人の
call/cc で取得する継続と一対一で対応しません。えー、マジかよーって感じですが、
まぁマジです。私も誤解してました。

では、何かというと「継続渡しスタイル（Continuation Passing Style）」 とかで言
われる「継続」です。

参考： www.shiro.dreamhost.com/scheme/wiliki/wiliki.cgi?Scheme%3aCPS?

たとえば、

(define (adder/cps x y cont/proc)
  (cont/proc (+ x y)))

(define (main)
  (adder/cps 1 2 display))

という定義があったとき、 (main) という式は何をやるか、を日本語で書いてみると、

mainさん: 「adder/cps さん、1 と 2 を渡すから、それを計算した

  結果を display に渡してね」

adder/cpsさん： 「mainさんから 1 と 2 と display を受け取ったぞ、俺の仕事は 1
と 2 を足すことだから、その結果を display に渡そう。これで俺の仕事終わり」

display さん: 「3 を表示すんのね」

こんな感じになりましょうか。

たとえば、main さんが display じゃなくて、やっぱり改行したいから display の代
わりに (lambda (arg) (display arg) (newline)) を渡しても正しく動きます。

また、adder/cps が、cont/proc を実行しないで、どこかに保存して返ってしまうこと
もできます。たとえば、

(define next #f)

(define (adder/cps x y cont/proc)
  (set! next (lambda () (cont/proc (+ x y)))))

このようにすると、

(main) ;; undef
(next) ;; -> 3 を表示

のようなことができます。

さて、ウェブアプリケーションで継続を扱えると何が嬉しいのでしょうか。

ウェブアプリケーションで考えると、HTTP自体がステートレスな通信なので、基本的に
1リクエスト、レスポンスでやることを全部やらないといけません。そのため、複雑な
インタラクションをするようなアプリケーションの実装は困難でした。たとえばセッシ
ョンオブジェクトを利用して実装していましたが、セッション情報として「継続」の代
わりになる情報をすべて保存しなければなりませんでした。

そこで、Kahua では「継続」の保存と復帰を非常に扱いやすいものにしました。つま
り、サーバ側ではある処理を中断したとき「クライアントからこのアクションがあった
ら続きとしてこれをやる」ということを簡単に登録できます。具体的にクライアントの
アクションとは何か、ということになるとたとえば「あるリンクをクリックする（ある
ページを要求する）」ことや「あるフォームを入力する」 ことにあたります。

では、具体的に何か作って見ましょう。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

しかし、hello にどういう継続を入れますかねぇ。

リンクをクリックすると、数をどんどん増やすようなアプリケーションにしてみましょ
うか。やっぱり実用性無さげですが。

そんなもん、session とかで情報を渡しても出来るわ！とか言われそうですが、まぁ簡
単なサンプルってことで。

(define-entry (counter)
  (define (viewer count)
    (page "hello kahua! - counter"
          (h1/ "Hello Kahua!")
          (h2/ (format "count is ~a" count))
          (p/
           (a/cont/ (@@/ (cont
                          (lambda () (viewer (+ count 1)))))
                    "inc count") " , "
           (a/cont/ (@@/ (cont
                          (lambda () (viewer (- count 1)))))
                    "dec count")
           )))
  (viewer 0))

こんな感じでしょうか。http : //.../kahua.cgi/hello/counter とアクセスすること
でこのページが表示されます。

a/cont/ というのは「このリンクをたどったとき、指定した継続を実行しろ」 とサー
バに登録するためのものです。継続の指定は「(@@/ (cont proc))」 と指定することで
行います。

つまり、(a/cont/ (@@/ (cont proc)) "...") と記述すると、「"..." というリンクを
たどると proc が実行」するような意味になります。

HTML ではリンクは <a href='dokka'> dokka </a> と書きますが、Kahua で (a/cont/
(@@/ (cont proc)) "dokka") と書くことで <a href=「proc を実行してくれるリン
ク」> dokka </a> と出力されます。

ここで、proc が継続になるわけです。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

次は、formの入力と、その入力を受取って実行するための継続を書いてみましょう。

数あて、でも作りますか。

(define-entry (find-number)
  (let ((correct (remainder (sys-random) 100)))
    (define (show-history history)
      (div/ (h2/ "履歴")
            (ol/
             (node-set
              (map (lambda (e) (li/ (x->string e)))
                   (reverse history))))))

    (define (hit-viewer history)
      (page "かずあてげーむ"
            (h1/ "あたり！")
            (h2/ (format "~a でした" correct))
            (if (null? history)
                (h2/ "しかもさいしょ！")
                (show-history history))))

    (define (viewer history guess)
      (page "かずあてげーむ"
            (div/
             (h1/ "かずあてげーむ(0 〜 99)")
             (if (null? history)
                 (p/ "さいしょ")
                 (div/
                  (h2/ (format "~a じゃないよ！" guess))
                  (if (integer? guess)
                      (h2/ "ヒント：もっと"
                           (if (> guess correct)
                               "ちいさいよ！" "おおきいよ！"))
                      (h2/ "読めないよ！"))
                  (show-history history)))
             (form/cont/ (@@/ (cont
                               (entry-lambda (:keyword guess)
                                 (let ((num (and guess
                                             (read-from-string guess))))
                                   (if (and
                                        (integer? num)
                                        (= num correct))
                                       (hit-viewer history)
                                       (viewer (cons num history) num))))))
                         (input/ (@/ (type "text") (name "guess")))
                         (input/ (@/ (type "submit")
                                     (value "これだ！")))
                         ))))
    (viewer '() 0)))

form/cont ってのが form で入力したデータを受ける継続を用意します。

ちょっと複雑ですが、なれればどおってことないので考えてみてください。

もっともっともっと hello - オブジェクトデータベースを使ってみよう

Kahua アプリケーションは、標準で（つまり、何もしなくても）オブジェクトデータベ
ースが利用できます。そのオブジェクトデータベースとは何か、というと、 Kahua に
おいては「永続化クラスが作成できる」ということになります。さて、では永続化クラ
スとはなんでしょうか。

通常、クラスのインスタンスの実体は、計算機のメモリにあります。つまり、その
（UNIXでいう）プロセスが終了すると、そのデータが消えてしまいます。ずっと残して
おきたいデータはその都度ファイルなどに書き出さなければなりません。

しかし、永続化オブジェクトは、そのインスタンスの保存を勝手にやってくれます。ど
のくらい勝手にやってくれるかというと、通常のスロットアクセス、スロットへの変数
の代入を行うと、それが外部データベースに反映されます。つまり、永続化オブジェク
トを利用すると、いちいちファイルへ出力するような処理をかかなくても、たとえばプ
ロセス再起動後もそのデータをアクセスできたり、複数プロセスとデータを共有できた
りします。

さて、オブジェクトデータベース、永続化オブジェクトやインスタンスなどという言葉
が出てきましたが、お察しのとおり、これらは Gauche のオブジェクトシステムを利用
します。これは、Common Lisp 由来の CLOS のサブセットになっています。Gauche の
オブジェクトシステムを知らない人は、まぁこうやってデータ構造を作るんだな、と思
ってください。知ってる人は、Gauche のオブジェクトが勝手にシリアライズされるん
だな、と思ってください。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

では、とりあえずサンプルプログラムを作ってみましょう。「データベース」っていう
くらいだから、データを保存するようなプログラムになりますよね。 hello にデータ
を保存するような処理を加えるわけですが、何がありまるかね。とりあえず、アクセス
カウンターでも作って見ますか。

アクセスされた回数を保存する、簡単な Gauche のクラスを作って、それを Kahua プ
ログラムに組み込みます。

;; アクセスカウントを記録するためのクラス
(define-class <access-counter> ()
  ((counter :init-value 1)))

クラスはこんな感じでしょうか。Gauche のオブジェクトシステムに慣れてない人のた
めに、Java、C++、Ruby で書いてみました。

// Java
class AccessCounter{
  public int counter;
  public AccessCounter(){ counter = 1; }
}

// C++
class AccessCounter{
public:
  int counter;
  AccessCounter(){ coutner = 1; }
}

# Ruby
class AccessCounter
  attr_accessor :counter
  def initialize
    @counter = 1
  end
end

多分、こんな感じだと思います。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

では、この簡単なクラスを永続化クラスに変更しましょう。

(define-class <access-counter> (<kahua-persistent-base>)
  ((counter :init-value 1
            :allocation :persistent)))

このようになります。変更個所は「<kahua-persistent-base>クラスを継承しているこ
と」と、「counter slot の :allocation 属性に :persistent が設定されたこと」で
す。

永続化クラスにするには、<kahua-persistent-base> クラスを継承するだけで大丈夫な
のですが、そのとき、永続化情報として保存されるのが :allocation 属性に
:persistent が指定されたスロット（Java でいうフィールド、C++ でいうメンバ変
数、Ruby でいうインスタンス変数）が対象になります。

さて、ここでは <access-counter> クラスは counter スロットを勝手に保存してくれ
てしまう凄いクラス（永続化クラス）になりました。簡単ですね。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

最後に、hello プログラムに追加してみましょう。

(define-class <access-counter> (<kahua-persistent-base>)
  ((counter :init-value 1
            :allocation :persistent)))

(define-method key-of ((obj <access-counter>))
  "key")

(define-method count-up! ((obj <access-counter>))
  (let1 count (ref obj 'counter)
    (set! (ref obj 'counter) (+ count 1))
    count))

(define (access!)
  (let1 counter (find-kahua-instance <access-counter> "key")
        (if counter
            (x->string (count-up! counter))
            (begin (make <access-counter>) "1"))))

(define-entry (hello-kahua)
  (page "hello kahua!" ;; title
        (div/
         (h1/ "Hello Kahua!")
         (p/ "あなたは" (access!) "人目の Helloer です"))))

なにやらまたゴテゴテと足されていますが、順番に調べていきます。key-of というメ
ソッドを定義していますが、これはインスタンス検索のときのキーに使います。このキ
ーは、この定義ではいつも "key" と返すので、いつ検索しても "key" という単語で検
索できます。逆を言うと、複数のインスタンスを作っても、最初にヒットしたものしか
検索できません。その点、少し特殊な例になってしまいました。

ちなみに、このキーは String でなければなりません。

count-up! は、<access-counter> オブジェクトの counter を 1 増やします。

access! 関数はまず、 find-kahua-instance で <access-counter> クラスのインスタ
ンスを、キーを "key" にして検索します。もしなければ #f が入り、ヒットすればそ
のインスタンスが得られます。見つからなかった場合、新しいインスタンスを make し
ています。

アクセスすると、「あなたは??人目の Helloer です」という文字が見えれば成功で
す。また、このサーバを再起動してもこの数字は続きからカウントアップしていきま
す。

オブジェクトデータベースの例も、まぁだいたいこんなもんですかね。

オブジェクトデータベース補足

今回の例ではインスタンスが一つしかない例を考えましたが、たとえば掲示板を考える
と、1投稿1オブジェクトにするのが普通です。また、各ページにアクセスカウンタを付
けたいというときもあるでしょう。そのとき、アクセスカウンタオブジェクトが複数生
成されるはずです。

このとき、複数の投稿、または複数のアクセスカウンタのうち、「どれか」を明示する
のが key-of メソッドになります。たとえば、この検索キーをアクセスカウンタの場合
として「ページ名」としたければ、key-of メソッドをそのアクセスカウンタが置かれ
ているページ名を返すメソッドとして定義しておきます（そのページ名は永続化される
スロットとして格納しておくことになるんでしょうね）。

key-of を定義しない場合、key-of は id へのシンプルなアクセッサ（(ref obj
'id)）になります。また、id slot へ何も設定しなければ、勝手に id が振られます。

あるクラスについての集合を得るには、 make-kahua-collection メソッドを使いま
す。クラスを指定すると、そのクラスについてデータベースに格納されているインスタ
ンス全部のコレクションを返してくれます。このコレクションは、 (use
gauche.collection) しておけば map や for-each のようなリストに対する演算をその
まま適用できます。

詳細：kahua.persistence

hello 全部

作成した hello.kahua のソースを載せてみます。

(define (page ttl . elems)
  (html/ (head/ (title/ ttl))
         (body/ (node-set elems))))


(define-class <access-counter> (<kahua-persistent-base>)
  ((counter :init-value 1
            :allocation :persistent)))

(define-method key-of ((obj <access-counter>))
  "key")

(define-method count-up! ((obj <access-counter>))
  (let1 count (ref obj 'counter)
    (set! (ref obj 'counter) (+ count 1))
    count))

(define (access!)
  (let1 counter (find-kahua-instance <access-counter> "key")
        (if counter
            (x->string (count-up! counter))
            (begin (make <access-counter>) "1"))))

(define-entry (hello-kahua)
  (page "hello kahua!" ;; title
        (div/
         (h1/ "Hello Kahua!")
         (p/ "あなたは" (access!) "人目の Helloer です"))))

(define-entry (world)
  (page "hello kahua! - world"
        (h1/ "Hello Kahua!")
        (h2/ "Hello World!")))

(define-entry (counter)
  (define (viewer count)
    (page "hello kahua! - counter"
          (h1/ "Hello Kahua!")
          (h2/ (format "count is ~a" count))
          (p/
           (a/cont/ (@@/ (cont
                          (lambda () (viewer (+ count 1)))))
                    "inc count") " , "
           (a/cont/ (@@/ (cont
                          (lambda () (viewer (- count 1)))))
                    "dec count")
           )))
  (viewer 0))

(define-entry (find-number)
  (let ((correct (remainder (sys-random) 100)))
    (define (show-history history)
      (div/ (h2/ "履歴")
            (ol/
             (node-set
              (map (lambda (e) (li/ (x->string e)))
                   (reverse history))))))

    (define (hit-viewer history)
      (page "かずあてげーむ"
            (h1/ "あたり！")
            (h2/ (format "~a でした" correct))
            (if (null? history)
                (h2/ "しかもさいしょ！")
                (show-history history))))

    (define (viewer history guess)
      (page "かずあてげーむ"
            (div/
             (h1/ "かずあてげーむ(0 〜 99)")
             (if (null? history)
                 (p/ "さいしょ")
                 (div/
                  (h2/ (format "~a じゃないよ！" guess))
                  (if (integer? guess)
                      (h2/ "ヒント：もっと"
                           (if (> guess correct)
                               "ちいさいよ！" "おおきいよ！"))
                      (h2/ "読めないよ！"))
                  (show-history history)))
             (form/cont/ (@@/ (cont
                               (entry-lambda (:keyword guess)
                                 (let ((num (and guess
                                             (read-from-string guess))))
                                   (if (and
                                        (integer? num)
                                        (= num correct))
                                       (hit-viewer history)
                                       (viewer (cons num history) num))))))
                         (input/ (@/ (type "text") (name "guess")))
                         (input/ (@/ (type "submit")
                                     (value "これだ！")))
                         ))))
    (viewer '() 0)))


(initialize-main-proc hello-kahua)

http : //.../kahua.cgi/hello で hello-kahua が呼ばれ、http:
//.../kahua.cgi/hello/find-number 、http : //.../kahua.cgi/hello/counter 、
http : //.../kahua.cgi/hello/world でそれぞれ find-number 、counter 、world 手
続きが呼ばれることになります。

Kahua プログラミング環境

Kahua にはいろいろ便利なユーティリティが付属しています。本項ではそれらについて
簡単に説明します。

kahua-admin の利用

kahua-admin は動いている Kahua システムに対する管理機能を提供します。

サーバの再起動、再読み込み、サーバへの接続（Schemeの評価可能な repl でサーバプ
ロセスに対するアクセスが可能）などが行えます。

これを利用することで、kahuaプログラムのリロードのために kahua-spvr の再起動を
行わなくてよくなります。

詳細： kahua-admin

kahua-shell の利用

kahua-shell は、あるサーバへ接続可能にします（Schemeの評価可能な repl でサーバ
プロセスに対するアクセスが可能）。また、このアクセスには認証をかけることができ
ます。

詳細： kahua-shell

Emacs との連携

kahua-shell は emacs と一緒に使うことを主に考えています。emacs の scheme-mode
の scheme-send-* 機能を利用することで、動作中のサーバの挙動を簡単に変更するこ
とができます。emacs を使っている人は、是非試してください。

詳細： kahua-shell

ユーザ別 Kahua 環境の利用

本番運用のための Kahua サーバと、自分の実験用の Kahua サーバを分けることができ
ます。

詳細： UserExclusiveMode

テストの作成

作った Kahua プログラムのテストを、簡単なパターンマッチング言語を使って作るこ
とができます。

詳細： kahua.test.xml kahua.test.worker

終わりに

これでチュートリアルは終わりです。百聞は一見にしかず、是非一度 Kahua を試して
みてください。

もし、わからないところがあれば、お気軽にメーリングリストなどでご質問ください。

メーリングリスト：Mailing List

Kahua は発展途上です。あなたが望めばあなたも Kahua core の開発者！　とりあえず
メーリングリストにご参加ください。

Kahua の情報は今後も http://www.kahua.org/ で公開していく予定です。

Happy Kahua Programming!
