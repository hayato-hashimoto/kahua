#!/usr/bin/env gosh
;; Communicate to kahua application server
;; $Id: kahua.cgi.in,v 1.18 2004/04/07 09:51:30 nobsun Exp $

;; This cgi script is kicked by httpd and pass through the request
;; to one of kahua servers.

;; The server to connect is determined as follows:
;;
;;  1. If PATH_INFO is given, its first component is regarded as a
;;     app-server type, and the rest is used as a cgsid.  Query
;;     parameters are ignored.   If more than one app-servers of
;;     that type are running, the client can't specify which
;;     server it will connect.
;;  2. If "x-kahua-cgsid" query parameter is given, the cgsid is
;;     taken from it and the app-server worker id is extracted.
;;  3. Otherwise, just connect to the supervisor and let it decide
;;     which app-server to handle the request.

(add-load-path "##libdir##")

(use gauche.net)
(use gauche.charconv)
(use gauche.logger)
(use srfi-1)
(use srfi-2)
(use srfi-13)
(use www.cgi)
(use util.list)
(use rfc.cookie)
(use rfc.base64)
(use rfc.sha1)
(use text.html-lite)
(use kahua.gsid)
(use kahua.config)
(use kahua.developer)
(use file.util)


;; Change this if you're using non-default sockbase
(define *sockbase* "unix:##KAHUA_SOCKET_BASE##")

;; bridge name option, mainly to pass "~user" information
(define *bridge-option* "")

(log-open "/tmp/t.log")

(define (kcv value)
  (ces-convert value "*jp" (gauche-character-encoding)))

(define (compose-reply header body)
  (let ((status (assoc-ref header "x-kahua-status"))
	(header (if (assoc-ref header "content-type") header
		    (cons '("content-type" 
                            (format "text/html; charset=~s" 
                                    (gauche-character-encoding)))
			  header))))
    (if (and status (equal? (car status) "SPVR-ERROR"))
	(cgi-error-page (string-append "SPVR-ERROR: " (car body)) (cadr body))
	(receive (state cont) (get-gsid-from-header header)
	  (for-each (lambda (hdr) ((response 'setheader) (car hdr) (cadr hdr)))
		    (filter (lambda (hdr) (not (#/^x-kahua-/ (car hdr))))
			    header))
	  ((response 'setcookie) 
	   (construct-cookie-string
	    `(("x-kahua-sgsid" ,state
	       :path ,(sys-dirname
		       (or (sys-getenv "SCRIPT_NAME") "/"))))))
	  body))))

;; load kahua.conf with "user" argument when PATH_INFO has ~user component.
(define (load-user-config user-dir)
  ;; use default kahua conf file.
  (kahua-init #f :user (string-drop user-dir 1))
  (set! *bridge-option* (string-append "/" user-dir))
  (set! *sockbase* (ref (kahua-config) 'sockbase)))

;; retrieve PATH_INFO, with processing ~user component.
;; returns #f if there's no PATH_INFO.
(define (get-path-info)
  (and-let* ((p (sys-getenv "PATH_INFO"))
             (l (cdr (string-split p #\/))))
    (when (and (pair? l) (#/^~.+/ (car l)))
      (load-user-config (car l))
      (set! l (cdr l)))
    (and (pair? l)
         (not (equal? (car l) ""))
         (filter-map (lambda (p) (if (equal? p "") #f p)) l))))

;; determine dispatch destination.
;; returns: (worker-id worker-type cont-gsid path-info)
(define (dispatch-destination params)
  (let* ((path-info   (get-path-info))
         (cont-gsid   (or (cgi-get-parameter "x-kahua-cgsid" params)
                          (if (and path-info (pair? (cdr path-info)))
                            (cadr path-info)
                            #f)))
         (worker-type (and path-info (car path-info)))
         (worker-id   (and cont-gsid (gsid->worker-id cont-gsid)))
         )
    (values worker-id worker-type cont-gsid path-info)))

;; construct absolute uri for the server root.
;; note that we can only guess the protocol scheme.
(define (server-uri)
  (let ((scheme (if (sys-getenv "HTTPS") "https" "http"))
        (name   (or (sys-getenv "SERVER_NAME") "localhost"))
        (port   (or (x->integer (sys-getenv "SERVER_PORT")) 80)))
    (format "~a://~a~a"
            scheme name
            (if (or (and (string=? scheme "http")  (= port 80))
                    (and (string=? scheme "https") (= port 443)))
                 ""
                 #`":,port"))))

;; prepare headers and dispatch the request to the appropriate server,
;; then receives the reply and forward it to the client.
(define (send-reply param)
  (receive (worker-id worker-type cont-gsid path-info)
      (dispatch-destination param)
    (log-format "~s ~s ~s" worker-id worker-type cont-gsid)
    (let* ((state-gsid (cgi-get-parameter "x-kahua-sgsid" param))
           (remote-addr (sys-getenv "REMOTE_ADDR"))
           (header     (list*
                        `("x-kahua-bridge"
                          ,(string-append (sys-getenv "SCRIPT_NAME")
                                          *bridge-option*))
                        `("x-kahua-server-uri" ,(server-uri))
                        (cond-list
                         (worker-type `("x-kahua-worker" ,worker-type))
                         (state-gsid `("x-kahua-sgsid" ,state-gsid))
                         (cont-gsid  `("x-kahua-cgsid" ,cont-gsid))
                         (path-info  `("x-kahua-path-info" ,path-info))
                         (remote-addr `("remote-addr" ,remote-addr)))))
           (sockaddr   (worker-id->sockaddr worker-id *sockbase*))
           )
      (log-format "cgsid: ~a (~a)" cont-gsid remote-addr)
      (call-with-client-socket (make-client-socket sockaddr)
        (lambda (in out)
          (write header out) (newline out)
          (write param  out) (newline out)
          (flush out)
          (let* ((header (read in))
                 (body   (read in)))
            (compose-reply header body))))
      )))

;; dispatcher of http response representation.
;; provide control over output headers, set cookies, redirect.
(define response
  (let ((headers '())
        (cookies '())
        (location #f))
    (define (publish body)
      (list
       (apply cgi-header :cookies cookies :location location headers)
       body))
    (lambda (a)
      (cond ((eq? a 'setheader)
             (lambda (name value)
               (set! headers (append
                              (list (make-keyword name) value) headers))))
            ((eq? a 'setcookie)
             (lambda (x) (set! cookies (append x cookies))))
            ((eq? a 'setredirect)
             (lambda (url) (set! location url)))
            ((eq? a 'headers) headers)
            ((eq? a 'cookies) cookies)
            ((eq? a 'redirect) location)
            ((eq? a 'publish) publish)
            (else (error "the key not found." a)))
      )))

;; publish html. provide ~user authentication.
(define (publisher params)
  (let* ((path-info (sys-getenv "PATH_INFO"))
	 (p (cadr (string-split (if (or (not path-info) 
					(string-null? path-info)) 
				    "/" path-info) #\/))))
    (
     (response 'publish)
     ;; make a body.
     (if (#/^~.+/ p)
       (begin
         ;; ~user authentication
         (let ((name (string-drop p 1))
               (passwd (or (cgi-get-parameter "kahua-passwd-plain"
                                              params :default #f)
                           (base64-decode-string
                            (cgi-get-parameter "kahua-passwd"
                                               params :default "")))))
           (if (kahua-check-developer name passwd)
             (begin
               ;; when login successed, set passwd to cookie.
               ((response 'setcookie)
                (construct-cookie-string
                 `(("kahua-passwd" ,(base64-encode-string passwd)
                    :path ,(sys-dirname
                            (or (sys-getenv "SCRIPT_NAME") "/"))))))
               (send-reply params))
             (unauthorized-form)
             ))
         )
       (send-reply params)
       ))
    ))

;; ~user login form.
;; when login failed, show this.
(define (unauthorized-form)
  `(,(html-doctype)
    ,(html:html
      (html:head (html:title "Unauthorized"))
      (html:body (html:h1 "Unauthorized")
                 (html:form :method "post"
                   (html:span "password")
                   (html:input :type "password" :name "kahua-passwd-plain")
                   (html:input :type "submit" :value "login"))))))

(define (main args)
  (cgi-main publisher
            :merge-cookies #t
            :on-error cgi-error-proc
            )
  0)


(define (get-error-string e)
  (call-with-output-string
   (cut with-error-to-port <> (cut report-error e))))

(define (cgi-error-page message detail)
  `(,(html-doctype)
    ,(html:html
      (html:head (html:title "Error"))
      (html:body
       (html:h1 "Error")
       (html:div
	(html:p (html-escape-string message))
	(html:pre (html-escape-string detail)))))))

(define (cgi-error-proc e)
  `(,(cgi-header)
    ,(cgi-error-page (string-append "CGI Error: " (slot-ref e 'message))
		  (get-error-string e))))


;; local variables:
;; mode: scheme
;; end:
